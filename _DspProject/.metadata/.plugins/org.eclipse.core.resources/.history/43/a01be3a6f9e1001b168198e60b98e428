//#############################################################################
//
// FILE:  main.c
// TITLE: SCI Flash Kernel
//
//#############################################################################

//
// Included Files
//
#include "driverlib.h"
#include "device.h"
#include "string.h"
#include "erase.h"
#include "flash_programming_c28.h"
#include "F021_F28004x_C28x.h"
#include "bootrom.h"
#include "flash.h"
#include "gpio.h"

// Function prototypes
void initFlashSectors(void);
void Error(Fapi_StatusType status);
extern uint32_t sciGetFunction(uint32_t BootMode);
extern uint32_t canGetFunction(uint32_t BootMode);
extern void sciaFlush(void);
extern void canInit(uint32_t BootMode);
extern void canKeyCheck(uint16_t word);

uint16_t checkDfuStatus(uint32_t destAddr, uint16_t* data)
void writeDfuStatus(uint32_t destAddr, uint16_t* data)

#pragma CODE_SECTION(Error,".TI.ramfunc");

//
// Main
//
uint32_t main(void)
{
    uint32_t EntryAddr;
    uint16_t u16_DataBuffer[2] = {0x1234, 0x5678};

    // initialize device
    Device_init();
    Device_initGPIO();

    // init interrupt and vectorTable
    Interrupt_initModule();
    Interrupt_initVectorTable();

    // Enable Global Interrupt(INTM) and realtime interrupt(DBGM)
    EINT;
    ERTM;

    // initialize flash sectors, fapi + driverlib
    initFlashSectors();

    // check user fw
    // if user fw ok -> change entry addr
    checkDfuStatus();


    EntryAddr = canGetFunction(CAN_BOOT);

    writeDfuStatus();

    return EntryAddr;
}

uint16_t checkDfuStatus(uint32_t destAddr, uint16_t* data)
{
    Fapi_StatusType oReturnCheck;
    Fapi_FlashStatusWordType oFlashStatusWord;
    //uint16_t u16_DataBuffer[2] = {0x1234, 0x5678};
    //uint32_t u32_DestAddr = 0x9A000;

    EALLOW;

    // Verify
    uint32_t toVerify = data[1];
    toVerify = (toVerify << 16) | data[0];

    oReturnCheck = Fapi_doVerify((uint32_t *)destAddr, 1, (uint32_t *)(&toVerify), &oFlashStatusWord);

    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck);
    }

    EDIS;

}

void writeDfuStatus(uint32_t destAddr, uint16_t* data)
{
    Fapi_StatusType oReturnCheck;
    uint16_t u16_DataBuffer[2] = {0x1234, 0x5678};
    uint32_t u32_DestAddr = 0x9A000;

    EALLOW;

    // Issue program command
    oReturnCheck = Fapi_issueProgrammingCommand((uint32_t *)u32_DestAddr, u16_DataBuffer,
                                                sizeof(u16_DataBuffer), 0, 0, Fapi_AutoEccGeneration);

    // Wait until the flash program operation is over
    while (Fapi_checkFsmForReady() != Fapi_Status_FsmReady) { }

    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck);
    }

    EDIS;
}

// initFlashSectors - Initialize the flash API
void initFlashSectors(void)
{
    EALLOW;

    Fapi_StatusType oReturnCheck;

    oReturnCheck = Fapi_initializeAPI(F021_CPU0_BASE_ADDRESS, 100);
    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck); // LED로 표시하게 할까?
    }

    oReturnCheck = Fapi_setActiveFlashBank(Fapi_FlashBank0);
    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck);
    }

    EDIS;

    // enable Error correction
    Flash_enableECC(FLASH0ECC_BASE);
}

// Error - Error function that will halt debugger
void Error(Fapi_StatusType status)
{
    // Error code will be in the status parameter
    __asm("    ESTOP0");;
}

//
// End of File
//
