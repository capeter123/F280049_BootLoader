//#############################################################################
//
// FILE:  main.c
// TITLE: SCI Flash Kernel
//
//#############################################################################

//
// Included Files
//
#include "driverlib.h"
#include "device.h"
#include "string.h"
#include "erase.h"
#include "flash_programming_c28.h"
#include "F021_F28004x_C28x.h"
#include "bootrom.h"
#include "flash.h"
#include "gpio.h"

#define USER_FW_ENTRY_ADDR  0x090000    // flash bank sector 0

// Function prototypes
void initFlashSectors(void);
void Error(Fapi_StatusType status);
extern uint32_t sciGetFunction(uint32_t BootMode);
extern uint32_t canGetFunction(uint32_t BootMode);
extern void sciaFlush(void);
extern void canInit(uint32_t BootMode);
extern void canKeyCheck(uint16_t word);

Fapi_StatusType checkDfuStatus(uint32_t destAddr, uint16_t* data);
void writeDfuStatus(uint32_t destAddr, uint16_t* data);
void eraseDfuStatus(uint32_t destAddr);

#pragma CODE_SECTION(Error,".TI.ramfunc");

//
// Main
//
uint32_t main(void)
{
    uint32_t EntryAddr;
    uint16_t u16_DataBuffer[2] = {0x1234, 0x5678};

    // initialize device
    Device_init();
    Device_initGPIO();

    // init interrupt and vectorTable
    Interrupt_initModule();
    Interrupt_initVectorTable();

    // Enable Global Interrupt(INTM) and realtime interrupt(DBGM)
    EINT;
    ERTM;

    // initialize flash sectors, fapi + driverlib
    initFlashSectors();

    writeDfuStatus(0x082FFE, u16_DataBuffer);




    // check user fw
    // if user fw ok -> change entry addr
    if(checkDfuStatus(0x082FFE, u16_DataBuffer) == Fapi_Status_Success) {
        return USER_FW_ENTRY_ADDR;
    }

    EntryAddr = canGetFunction(CAN_BOOT);

    writeDfuStatus(0x082FFE, u16_DataBuffer);

    return EntryAddr;
}

Fapi_StatusType checkDfuStatus(uint32_t destAddr, uint16_t* data)
{
    Fapi_StatusType oReturnCheck;
    Fapi_FlashStatusWordType oFlashStatusWord;
    //uint16_t u16_DataBuffer[2] = {0x1234, 0x5678};
    //uint32_t u32_DestAddr = 0x9A000;

    EALLOW;

    // Verify
    uint32_t toVerify = data[1];
    toVerify = (toVerify << 16) | data[0];

    oReturnCheck = Fapi_doVerify((uint32_t *)destAddr, 1, (uint32_t *)(&toVerify), &oFlashStatusWord);

    EDIS;

    return oReturnCheck;
}

void writeDfuStatus(uint32_t destAddr, uint16_t* data)
{
    Fapi_StatusType oReturnCheck;
    uint16_t u16_DataBuffer[2];

    u16_DataBuffer[0] = data[0];
    u16_DataBuffer[1] = data[1];

    EALLOW;

    // Issue program command
    oReturnCheck = Fapi_issueProgrammingCommand((uint32_t *)destAddr, u16_DataBuffer,
                                                sizeof(u16_DataBuffer), 0, 0, Fapi_AutoEccGeneration);

    // Wait until the flash program operation is over
    while (Fapi_checkFsmForReady() != Fapi_Status_FsmReady) { }

    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck);
    }

    EDIS;
}

void eraseDfuStatus(uint32_t destAddr)
{
    Fapi_StatusType oReturnCheck;

    oReturnCheck = Fapi_issueAsyncCommandWithAddress(
                        Fapi_EraseSector, (uint32_t *)destAddr);
    //
    // wait until AsyncCommand is done.
    //
    while (Fapi_checkFsmForReady() != Fapi_Status_FsmReady)
    {
    }

}


// initFlashSectors - Initialize the flash API
void initFlashSectors(void)
{
    EALLOW;

    Fapi_StatusType oReturnCheck;

    oReturnCheck = Fapi_initializeAPI(F021_CPU0_BASE_ADDRESS, 100);
    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck); // LED로 표시하게 할까?
    }

    oReturnCheck = Fapi_setActiveFlashBank(Fapi_FlashBank0);
    if (oReturnCheck != Fapi_Status_Success)
    {
        Error(oReturnCheck);
    }

    EDIS;

    // enable Error correction
    Flash_enableECC(FLASH0ECC_BASE);
}

// Error - Error function that will halt debugger
void Error(Fapi_StatusType status)
{
    // Error code will be in the status parameter
    __asm("    ESTOP0");;
}

//
// End of File
//
